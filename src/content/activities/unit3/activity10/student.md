## Solución a la décima actividad: 
### Consolidación:
Luego de implementar la aplicación de la bomba interactiva usando p5.js y micro:bit, haciendo uso de la técnica de máquina de estados, puedo analizar con claridad algunas ventajas importantes en términos de escalabilidad, concurrencia y manejo de eventos. Esta técnica ha resultado poderosa porque permite organizar mi código en estados específicos (CONFIG, COUNTDOWN, EXPLODED), donde cada estado maneja de forma independiente los eventos que le corresponden. Esto facilita considerablemente la gestión simultánea de eventos provenientes de diferentes fuentes, como los sensores físicos del micro:bit y la interacción del usuario con la interfaz gráfica en p5.js. Al separar la lógica según cada estado claramente definido, puedo evitar conflictos entre eventos que suceden al mismo tiempo o muy cercanos entre sí, lo cual es fundamental cuando la aplicación crece y se vuelve más compleja. Además, añadir nuevos estados o eventos en el futuro resulta más sencillo, porque cada estado actúa como un bloque aislado que puede ajustarse sin afectar demasiado al resto del programa.

Respecto al tipo de pruebas realizadas durante esta unidad, identifiqué varias ventajas. Por ejemplo, al realizar pruebas directas con la interfaz gráfica y el micro:bit, pude detectar rápidamente problemas de usabilidad y verificar inmediatamente si la aplicación respondía correctamente a las acciones del usuario. Este método es particularmente útil porque refleja con fidelidad las condiciones reales bajo las cuales la aplicación será utilizada, permitiéndome ajustar detalles finos sobre cómo se sienten las interacciones para el usuario final. Sin embargo, también descubrí algunas desventajas. Las pruebas realizadas fueron mayormente manuales y basadas en la interacción directa, lo que las hizo más lentas y laboriosas, especialmente cuando se trataba de comprobar todos los escenarios posibles. Además, sin un método automatizado, existe un riesgo significativo de pasar por alto errores o condiciones específicas difíciles de reproducir manualmente. Pr eso resultaron fundamentales las pruebas de regresión. Este tipo de pruebas me permitió verificar que cada vez que realizaba un cambio o añadía una funcionalidad nueva, las funcionalidades anteriores seguían trabajando correctamente. Al ejecutar nuevamente todos los casos de prueba previos después de hacer modificaciones, pude detectar rápidamente cualquier problema inesperado introducido en el código reciente.

Si no realizara pruebas de regresión después de hacer cambios en mi aplicación, correría el riesgo de que pequeños ajustes pudieran romper funcionalidades previamente correctas sin darme cuenta. Esto haría más difícil rastrear cuándo y dónde se introdujo un error, complicando significativamente el proceso de depuración. Además, la estabilidad y la confianza en la aplicación disminuirían considerablemente, afectando directamente la calidad percibida por los usuarios.
